# Алгоритмы с логарифмической сложностью (O(log n)) выполняются быстрее, чем линейные алгоритмы (O(n)), их скорость роста
# ограничивается логарифмически по отношению к размеру входных данных. 

# 1.Бинарный поиск: Бинарный поиск - это алгоритм поиска элемента в упорядоченном массиве, который разделяет массив пополам
# на каждом шаге. Временная сложность бинарного поиска - O(log n), где n - количество элементов в массиве.
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

arr = [1, 2, 3, 4, 5, 6, 7, 10, 100, 150, 200]     
print('1.Бинарный поиск', binary_search(arr, 150))


# 2.Двоичное дерево поиска: Двоичное дерево поиска - это структура данных, которая обеспечивает быстрый поиск, вставку и удаление
# элементов. Временная сложность операций в двоичном дереве поиска - в среднем O(log n), где n - количество узлов в дереве.
# 3.Быстрая сортировка (Quick Sort): В среднем случае быстрая сортировка имеет временную сложность O(n log n). Этот алгоритм
# разделяет массив на подмассивы, сортирует их и затем объединяет весь массив. В среднем время разделения и объединения
# составляет O(log n), а каждый подмассив сортируется за O(n).
# 4.Алгоритмы на основе деления и правления: Множество алгоритмов на основе деления и правления (divide and conquer), такие как быстрое 
# возведение в степень, нахождение числа Фибоначчи и другие, имеют временную сложность O(log n) благодаря разделению задачи на более мелкие
# подзадачи и уменьшению размера данных на каждом шаге.
# 5.Алгоритмы на основе деревьев: Множество алгоритмов, работающих с деревьями, имеют логарифмическую сложность. Например, красно-черные 
# деревья и AVL-деревья обеспечивают O(log n) для операций вставки, поиска и удаления элементов.