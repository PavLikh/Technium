# Technium

<details>
<summary>4.1 Декораторы</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-1-decorators)

## Задача 1.
Измерьте с помощью декоратора measure_execution_time продолжительность HTTP запроса к произвольному url (можно взять код из первых уроков по ботам)

## Задача 2. 
Описание задачи:

Необходимо разработать декоратор requires_admin, который будет использоваться для проверки роли пользователя перед выполнением защищенной функции. Если роль пользователя не соответствует требуемой, декоратор должен выбрасывать исключение PermissionError. В противном случае функция должна выполняться корректно.

### Пример использования:

Функция delete_user отвечает за удаление пользователей. Она должна быть доступна только для пользователей с ролью "admin".  Если пользователь, вызывающий эту функцию, не является администратором, необходимо остановить выполнение функции и выбросить PermissionError.

 
```python
@requires_admin
def delete_user(user, username_to_delete):
    return f"User {username_to_delete} has been deleted by {user['username']}."
```
### Пример юзеров
```python
admin_user = {'username': 'Alice', 'role': 'admin'}
regular_user = {'username': 'Bob', 'role': 'user'}
```

### Вызовы функции
```python
print(delete_user(admin_user, 'Charlie')) # Должно отработать
print(delete_user(regular_user, 'Charlie')) # Должно рейзить PermissionError
```

</details>
<details>
<summary>4.5 Задача (последовательность скобок)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-5-task)

## Описание задачи
Необходимо написать программу, которая проверяет, является ли данная строка правильной скобочной последовательностью. Правильной скобочной последовательностью считается последовательность, в которой каждая открывающая скобка (например, '(', '{', '[') имеет соответствующую закрывающую скобку (')', '}', ']'). При этом скобки должны быть правильно вложены друг в друга, и порядок их следования должен быть корректным.

Примеры:

Правильная скобочная последовательность: "([]{})"
Неправильная скобочная последовательность: "([)]"
Неправильная скобочная последовательность: "{[}"
Правильная скобочная последовательность: "()"

Задача включает в себя следующие шаги:

- Считать строку, содержащую скобочную последовательность.
- Используя стек, проверить каждую скобку в строке.
- Если текущая скобка - открывающая, добавить ее в стек.
- Если текущая скобка - закрывающая, проверить, соответствует ли она последней открывающей скобке в стеке. Если да, удалить последнюю открывающую скобку из стека и продолжить проверку. В противном случае, скобочная последовательность неправильна.
- По завершении проверки всех символов в строке, проверить, остались ли какие-либо непарные скобки в стеке. Если да, скобочная последовательность также считается неправильной.

Результатом выполнения программы должно быть сообщение о том, является ли данная строка правильной скобочной последовательностью или нет. В идеале код должен содержать реализацию класса Стек и функцию для проверки строки со скобками. 
</details>
<details>
<summary>4.6 Обратная польская нотация</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-6-reverse_polish_notation)

## Обратная польская запись (Reverse Polish Notation, RPN - она же постфиксная нотация, или обратная польская нотация (ОПН)) 
-это форма записи математических выражений, в которой операторы располагаются после своих операндов. Это также называется постфиксной записью. обратной польской записи порядок выполнения операций однозначно определяется, и не требуется использование скобок для указания приоритета операций.

Пример обратной польской записи:

Обычное инфиксное выражение: 3 + 4 * 2
Обратная польская запись: 3 4 2 * +

В обратной польской записи каждый операнд считывается, а затем оператор выполняется над двумя последними операндами. В данном случае, сначала выполняется умножение 4 * 2, а затем результат (8) складывается с 3, чтобы получить окончательный результат (11).

Обратная польская запись имеет несколько преимуществ:

1. Она исключает неоднозначность в приоритете операторов, так как порядок операций однозначно определяется последовательностью операторов.
2. Она облегчает вычисления на стеке, что делает ее полезной для реализации калькуляторов и интерпретаторов математических выражений.
3. Она упрощает анализ и вычисление выражений в программах.

Для вычисления выражения в обратной польской записи можно использовать стек. 

Алгоритм решения задачи обратной польской записи с использованием стека можно разбить на несколько шагов:

- Создать пустой стек для хранения операндов.
- Разбить строку входного выражения на токены (числа и операторы).
- Для каждого токена во входном выражении выполнить следующее:
    - Если токен - операнд (число), поместить его в стек.
    - Если токен - оператор (+, -, *, /), извлечь два верхних элемента из стека (это будут операнды), выполнить операцию с ними и результат поместить обратно в стек.
- После обработки всех токенов входного выражения, в стеке должен остаться единственный элемент - результат вычислений.
</details>
<details>
<summary>4.7 Очередь</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-7-queue)

</details>