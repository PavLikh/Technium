# Technium

<details>
<summary>4.1 Декораторы</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-1-decorators)

## Задача 1.
Измерьте с помощью декоратора measure_execution_time продолжительность HTTP запроса к произвольному url (можно взять код из первых уроков по ботам)

## Задача 2. 
Описание задачи:

Необходимо разработать декоратор requires_admin, который будет использоваться для проверки роли пользователя перед выполнением защищенной функции. Если роль пользователя не соответствует требуемой, декоратор должен выбрасывать исключение PermissionError. В противном случае функция должна выполняться корректно.

### Пример использования:

Функция delete_user отвечает за удаление пользователей. Она должна быть доступна только для пользователей с ролью "admin".  Если пользователь, вызывающий эту функцию, не является администратором, необходимо остановить выполнение функции и выбросить PermissionError.

 
```python
@requires_admin
def delete_user(user, username_to_delete):
    return f"User {username_to_delete} has been deleted by {user['username']}."
```
### Пример юзеров
```python
admin_user = {'username': 'Alice', 'role': 'admin'}
regular_user = {'username': 'Bob', 'role': 'user'}
```

### Вызовы функции
```python
print(delete_user(admin_user, 'Charlie')) # Должно отработать
print(delete_user(regular_user, 'Charlie')) # Должно рейзить PermissionError
```

</details>
<details>
<summary>4.5 Задача (последовательность скобок)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-5-task)

## Описание задачи
Необходимо написать программу, которая проверяет, является ли данная строка правильной скобочной последовательностью. Правильной скобочной последовательностью считается последовательность, в которой каждая открывающая скобка (например, '(', '{', '[') имеет соответствующую закрывающую скобку (')', '}', ']'). При этом скобки должны быть правильно вложены друг в друга, и порядок их следования должен быть корректным.

Примеры:

Правильная скобочная последовательность: "([]{})"
Неправильная скобочная последовательность: "([)]"
Неправильная скобочная последовательность: "{[}"
Правильная скобочная последовательность: "()"

Задача включает в себя следующие шаги:

- Считать строку, содержащую скобочную последовательность.
- Используя стек, проверить каждую скобку в строке.
- Если текущая скобка - открывающая, добавить ее в стек.
- Если текущая скобка - закрывающая, проверить, соответствует ли она последней открывающей скобке в стеке. Если да, удалить последнюю открывающую скобку из стека и продолжить проверку. В противном случае, скобочная последовательность неправильна.
- По завершении проверки всех символов в строке, проверить, остались ли какие-либо непарные скобки в стеке. Если да, скобочная последовательность также считается неправильной.

Результатом выполнения программы должно быть сообщение о том, является ли данная строка правильной скобочной последовательностью или нет. В идеале код должен содержать реализацию класса Стек и функцию для проверки строки со скобками. 
</details>
<details>
<summary>4.6 Обратная польская нотация</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-6-reverse_polish_notation)

## Обратная польская запись (Reverse Polish Notation, RPN - она же постфиксная нотация, или обратная польская нотация (ОПН)) 
-это форма записи математических выражений, в которой операторы располагаются после своих операндов. Это также называется постфиксной записью. обратной польской записи порядок выполнения операций однозначно определяется, и не требуется использование скобок для указания приоритета операций.

Пример обратной польской записи:

Обычное инфиксное выражение: 3 + 4 * 2
Обратная польская запись: 3 4 2 * +

В обратной польской записи каждый операнд считывается, а затем оператор выполняется над двумя последними операндами. В данном случае, сначала выполняется умножение 4 * 2, а затем результат (8) складывается с 3, чтобы получить окончательный результат (11).

Обратная польская запись имеет несколько преимуществ:

1. Она исключает неоднозначность в приоритете операторов, так как порядок операций однозначно определяется последовательностью операторов.
2. Она облегчает вычисления на стеке, что делает ее полезной для реализации калькуляторов и интерпретаторов математических выражений.
3. Она упрощает анализ и вычисление выражений в программах.

Для вычисления выражения в обратной польской записи можно использовать стек. 

Алгоритм решения задачи обратной польской записи с использованием стека можно разбить на несколько шагов:

- Создать пустой стек для хранения операндов.
- Разбить строку входного выражения на токены (числа и операторы).
- Для каждого токена во входном выражении выполнить следующее:
    - Если токен - операнд (число), поместить его в стек.
    - Если токен - оператор (+, -, *, /), извлечь два верхних элемента из стека (это будут операнды), выполнить операцию с ними и результат поместить обратно в стек.
- После обработки всех токенов входного выражения, в стеке должен остаться единственный элемент - результат вычислений.
</details>
<details>
<summary>4.7 Очередь</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-7-queue)

</details>
<details>
<summary>4.8 Задача (очередь)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-8-task-queue)

Цель этого задания - создать программу для управления задачами с использованием структуры данных "очередь". Задачи будут представлены в виде объектов, и программа должна поддерживать операции добавления задачи в очередь, извлечения задачи из очереди и проверки состояния очереди.

### Требования 
1. Создайте класс TaskQueue, который будет представлять очередь задач. Этот класс должен иметь следующие методы:
    * add_task(task): Добавляет задачу task в конец очереди.
    * get_next_task(): Извлекает и возвращает задачу из начала очереди. Если очередь пуста, вернуть None.
    * is_empty(): Проверяет, пуста ли очередь. Возвращает True, если очередь пуста, и False в противном случае.
2. Создайте класс Task, который будет представлять задачу. Этот класс должен иметь атрибут:
    * name: Название задачи (строка).
3. Реализуйте логику работы с задачами в соответствии с их добавлением и извлечением из очереди.

Примеры тестовых данных и ожидаемых результатов:
```python
queue = TaskQueue()

task1 = Task("Задача 1")
task2 = Task("Задача 2")
task3 = Task("Задача 3")

queue.add_task(task1)
queue.add_task(task2)
queue.add_task(task3)

next_task = queue.get_next_task()
print(f"Следующая задача: {next_task.name if next_task else 'Нет задач'}")  # Ожидаемый результат: "Задача 1"

queue.get_next_task()  # Извлечь следующую задачу

print(f"Очередь пуста: {queue.is_empty()}")  # Ожидаемый результат: False
```

</details>
<details>
<summary>4.13 DFS через классы</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-13-grapf_dfs_class)


### Требования 
Дописать реализацию функции dfs() для графа. Подсказка: в функции должны использоваться 2 структуры - Список для хранения пройденных вершин и Стек для хранения вершин-соседей, которые нужно пройти - алгоритм в предыдущем уроке сильно поможет. 


Для тестирования
```python
a = Node('a')
b = Node('b')
c = Node('c')
d = Node('d')
e = Node('e')
f = Node('f')
g = Node('g')
h = Node('h')
i = Node('i')
k = Node('k')
a.point_to(b)
b.point_to(c)
c.point_to(d)
d.point_to(a)
b.point_to(d)
a.point_to(e)
e.point_to(f)
e.point_to(g)
f.point_to(i)
f.point_to(h)
g.point_to(k)

g = Graph(a)
print(g.dfs())
```

</details>
