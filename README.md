# Technium

<details>
<summary>4.1 Декораторы</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-1-decorators)

## Задача 1.
Измерьте с помощью декоратора measure_execution_time продолжительность HTTP запроса к произвольному url (можно взять код из первых уроков по ботам)

## Задача 2. 
Описание задачи:

Необходимо разработать декоратор requires_admin, который будет использоваться для проверки роли пользователя перед выполнением защищенной функции. Если роль пользователя не соответствует требуемой, декоратор должен выбрасывать исключение PermissionError. В противном случае функция должна выполняться корректно.

### Пример использования:

Функция delete_user отвечает за удаление пользователей. Она должна быть доступна только для пользователей с ролью "admin".  Если пользователь, вызывающий эту функцию, не является администратором, необходимо остановить выполнение функции и выбросить PermissionError.

 
```python
@requires_admin
def delete_user(user, username_to_delete):
    return f"User {username_to_delete} has been deleted by {user['username']}."
```
### Пример юзеров
```python
admin_user = {'username': 'Alice', 'role': 'admin'}
regular_user = {'username': 'Bob', 'role': 'user'}
```

### Вызовы функции
```python
print(delete_user(admin_user, 'Charlie')) # Должно отработать
print(delete_user(regular_user, 'Charlie')) # Должно рейзить PermissionError
```

</details>
<details>
<summary>4.5 Задача (последовательность скобок)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-5-task)

## Описание задачи
Необходимо написать программу, которая проверяет, является ли данная строка правильной скобочной последовательностью. Правильной скобочной последовательностью считается последовательность, в которой каждая открывающая скобка (например, '(', '{', '[') имеет соответствующую закрывающую скобку (')', '}', ']'). При этом скобки должны быть правильно вложены друг в друга, и порядок их следования должен быть корректным.

Примеры:

Правильная скобочная последовательность: "([]{})"
Неправильная скобочная последовательность: "([)]"
Неправильная скобочная последовательность: "{[}"
Правильная скобочная последовательность: "()"

Задача включает в себя следующие шаги:

- Считать строку, содержащую скобочную последовательность.
- Используя стек, проверить каждую скобку в строке.
- Если текущая скобка - открывающая, добавить ее в стек.
- Если текущая скобка - закрывающая, проверить, соответствует ли она последней открывающей скобке в стеке. Если да, удалить последнюю открывающую скобку из стека и продолжить проверку. В противном случае, скобочная последовательность неправильна.
- По завершении проверки всех символов в строке, проверить, остались ли какие-либо непарные скобки в стеке. Если да, скобочная последовательность также считается неправильной.

Результатом выполнения программы должно быть сообщение о том, является ли данная строка правильной скобочной последовательностью или нет. В идеале код должен содержать реализацию класса Стек и функцию для проверки строки со скобками. 
</details>
<details>
<summary>4.6 Обратная польская нотация</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-6-reverse_polish_notation)

## Обратная польская запись (Reverse Polish Notation, RPN - она же постфиксная нотация, или обратная польская нотация (ОПН)) 
-это форма записи математических выражений, в которой операторы располагаются после своих операндов. Это также называется постфиксной записью. обратной польской записи порядок выполнения операций однозначно определяется, и не требуется использование скобок для указания приоритета операций.

Пример обратной польской записи:

Обычное инфиксное выражение: 3 + 4 * 2
Обратная польская запись: 3 4 2 * +

В обратной польской записи каждый операнд считывается, а затем оператор выполняется над двумя последними операндами. В данном случае, сначала выполняется умножение 4 * 2, а затем результат (8) складывается с 3, чтобы получить окончательный результат (11).

Обратная польская запись имеет несколько преимуществ:

1. Она исключает неоднозначность в приоритете операторов, так как порядок операций однозначно определяется последовательностью операторов.
2. Она облегчает вычисления на стеке, что делает ее полезной для реализации калькуляторов и интерпретаторов математических выражений.
3. Она упрощает анализ и вычисление выражений в программах.

Для вычисления выражения в обратной польской записи можно использовать стек. 

Алгоритм решения задачи обратной польской записи с использованием стека можно разбить на несколько шагов:

- Создать пустой стек для хранения операндов.
- Разбить строку входного выражения на токены (числа и операторы).
- Для каждого токена во входном выражении выполнить следующее:
    - Если токен - операнд (число), поместить его в стек.
    - Если токен - оператор (+, -, *, /), извлечь два верхних элемента из стека (это будут операнды), выполнить операцию с ними и результат поместить обратно в стек.
- После обработки всех токенов входного выражения, в стеке должен остаться единственный элемент - результат вычислений.
</details>
<details>
<summary>4.7 Очередь</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-7-queue)

</details>
<details>
<summary>4.8 Задача (очередь)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-8-task-queue)

Цель этого задания - создать программу для управления задачами с использованием структуры данных "очередь". Задачи будут представлены в виде объектов, и программа должна поддерживать операции добавления задачи в очередь, извлечения задачи из очереди и проверки состояния очереди.

### Требования 
1. Создайте класс TaskQueue, который будет представлять очередь задач. Этот класс должен иметь следующие методы:
    * add_task(task): Добавляет задачу task в конец очереди.
    * get_next_task(): Извлекает и возвращает задачу из начала очереди. Если очередь пуста, вернуть None.
    * is_empty(): Проверяет, пуста ли очередь. Возвращает True, если очередь пуста, и False в противном случае.
2. Создайте класс Task, который будет представлять задачу. Этот класс должен иметь атрибут:
    * name: Название задачи (строка).
3. Реализуйте логику работы с задачами в соответствии с их добавлением и извлечением из очереди.

Примеры тестовых данных и ожидаемых результатов:
```python
queue = TaskQueue()

task1 = Task("Задача 1")
task2 = Task("Задача 2")
task3 = Task("Задача 3")

queue.add_task(task1)
queue.add_task(task2)
queue.add_task(task3)

next_task = queue.get_next_task()
print(f"Следующая задача: {next_task.name if next_task else 'Нет задач'}")  # Ожидаемый результат: "Задача 1"

queue.get_next_task()  # Извлечь следующую задачу

print(f"Очередь пуста: {queue.is_empty()}")  # Ожидаемый результат: False
```

</details>
<details>
<summary>4.13 DFS через классы</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-13-graph_dfs_class)


### Задание 
Дописать реализацию функции dfs() для графа. Подсказка: в функции должны использоваться 2 структуры - Список для хранения пройденных вершин и Стек для хранения вершин-соседей, которые нужно пройти - алгоритм в предыдущем уроке сильно поможет. 


Для тестирования
```python
a = Node('a')
b = Node('b')
c = Node('c')
d = Node('d')
e = Node('e')
f = Node('f')
g = Node('g')
h = Node('h')
i = Node('i')
k = Node('k')
a.point_to(b)
b.point_to(c)
c.point_to(d)
d.point_to(a)
b.point_to(d)
a.point_to(e)
e.point_to(f)
e.point_to(g)
f.point_to(i)
f.point_to(h)
g.point_to(k)

g = Graph(a)
print(g.dfs())
```

</details>
<details>
<summary>4.15 Breadth-First через классы</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-15-graph-bfs-class)

```python
class Node:
    def __init__(self, value):
        self.value = value

        self.outbound = []
        self.inbound = []

    def point_to(self, other):
        self.outbound.append(other)
        other.inbound.append(self)

    def __str__(self):
        return f'Node({self.value})'

class Graph:
    def __init__(self, root):
        self._root = root

    def dfs(self):
        pass

    def bfs(self):
        pass
```

С нуля новый код писать не нужно. Если вы успешно справились с предыдущим заданием, то функция dfs() у вас уже реализована и код bfs() будет ооооочень сильно на нее походить, но с небольшим отличием в алгоритме.
</details>
<details>
<summary>4.17 Сортировка пузырьком (Bubble sort)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-17-bubble_sort)

Сортировка пузырьком (Bubble Sort) - это простой алгоритм сортировки, который многократно проходит по списку, сравнивает пары соседних элементов и меняет их местами, если они находятся в неправильном порядке. Повторяйте этот процесс до тех пор, пока весь список не будет отсортирован. 

Вот пошаговое руководство по сортировке пузырьком:

`Шаг 1`:  Начните с начала списка. \
`Шаг 2`:  Сравните первый и второй элементы списка. Если первый элемент больше второго, поменяйте их местами. \
`Шаг 3`:  Перейдите к следующей паре элементов (второй и третий) и сравните их. Если второй элемент больше третьего, поменяйте их местами. \
`Шаг 4`:  Продолжайте двигаться по списку, сравнивая и меняя элементы, пока не достигнете конца списка. На этом этапе наибольший элемент "всплывет" до конца списка. \
`Шаг 5`:  Повторите шаги 1-4 для оставшейся части списка (исключая уже отсортированную часть). \
`Шаг 6`:  Повторяйте эти шаги, пока весь список не будет отсортирован. Это может потребовать нескольких проходов.

Важно отметить, что на каждом проходе наибольший элемент "всплывает" до конца списка, поэтому после первого прохода самый большой элемент будет находиться в конце, после второго - в предпоследнем месте, и так далее. Этот процесс продолжается до тех пор, пока весь список не будет упорядочен.
</details>
<details>
<summary>4.18 Сортировка вставками (Insertion sort)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-18-insertion_sort)

Сортировка вставками (Insertion Sort) - это алгоритм сортировки, который сначала считает первый элемент массива отсортированным и затем поочередно вставляет каждый следующий элемент в правильную позицию в отсортированной части массива. Вот пошаговое руководство по сортировке вставками:

`Шаг 1`: Начните со второго элемента (первый элемент считается уже отсортированным). \
`Шаг 2`: Сравните текущий элемент с предыдущим элементом в отсортированной части массива. \
`Шаг 3`: Если текущий элемент меньше предыдущего, переместите текущий элемент влево до тех пор, пока он не окажется в правильной позиции в отсортированной части. \
`Шаг 4`: Повторяйте шаги 2-3 для каждого следующего элемента в массиве, пока не достигнете конца массива. \
`Шаг 5`: После завершения этого процесса весь массив будет отсортирован.

Важно отметить, что на каждом шаге внутренний цикл перебирает отсортированную часть массива и перемещает текущий элемент влево, чтобы вставить его в правильную позицию. С каждой итерацией внешнего цикла отсортированная часть массива увеличивается.
</details>
<details>
<summary>4.19 Сортировка выбором (Selection sort)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-19-selection_sort)

Сортировка выбором (Selection Sort) - это алгоритм сортировки, который на каждом шаге выбирает минимальный (или максимальный) элемент из оставшейся части массива и помещает его в начало (или конец) отсортированной части массива. 

Вот пошаговое руководство по сортировке выбором:

`Шаг 1`: Начните с начала массива. \
`Шаг 2`: Найдите наименьший (или наибольший, в зависимости от порядка сортировки) элемент в оставшейся части массива. \
`Шаг 3`: Поменяйте найденный элемент с первым элементом в оставшейся части массива. \
`Шаг 4`: Повторяйте шаги 2-3 для каждой следующей позиции в массиве (после того элемента, который был только что отсортирован). На каждом шаге будет выбран следующий наименьший (или наибольший) элемент и помещен в соответствующую позицию. \
`Шаг 5`: Продолжайте этот процесс до тех пор, пока не будете перемещаться через весь массив. В конечном итоге весь массив будет отсортирован.

Важно отметить, что на каждом шаге внутренний цикл перебирает отсортированную часть массива и перемещает текущий элемент влево, чтобы вставить его в правильную позицию. С каждой итерацией внешнего цикла отсортированная часть массива увеличивается.
</details>
<details>
<summary>4.23 O(1) - Константная сложность</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-23-constant_time)

Алгоритмы с константной сложностью выполняются за постоянное время, независимо от размера входных данных. Их временная сложность обозначается как O(1). Вот несколько примеров алгоритмов с константной сложностью:

1. Получение элемента из массива по индексу: Если у вас есть массив (или список) и вы хотите получить элемент по его индексу, это занимает постоянное время, так как вы можете просто обратиться к этому элементу. Например:
```python
my_list = [1, 2, 3, 4, 5] 
element = my_list[2]  # Получить элемент по индексу 2 (значение 3) - O(1)

```

2. Добавление или удаление элемента из конца списка: Если вы добавляете или удаляете элемент из конца списка, это также выполняется за постоянное время, так как не требуется перебора всего списка. Например:
```python
my_list = [1, 2, 3, 4, 5] 
my_list.append(6)  # Добавить элемент в конец списка - O(1)
my_list.pop()  # Удалить элемент из конца списка - O(1)
```

3. Хеширование: Если у вас есть функция хеширования, которая преобразует данные в фиксированный хеш-код, поиск значения по хеш-коду выполняется за постоянное время. Например, в Python есть словари (dict), которые используют хеш-таблицы для быстрого доступа к значениям по ключу:
```python
my_dict = {'a': 1, 'b': 2, 'c': 3} 
value = my_dict['b']  # Получить значение по ключу 'b' - O(1)
```

4. Получение длины контейнера: Получение длины списка, строки или другого контейнера также выполняется за постоянное время, так как длина часто хранится как атрибут контейнера и не требует пересчета. Например:
```python
my_list = [1, 2, 3, 4, 5] 
length = len(my_list)  # Получить длину списка - O(1)
```

Алгоритмы с константной сложностью очень эффективны и быстры в выполнении, независимо от размера данных.
</details>
<details>
<summary>4.24 O(n) - линейная сложность</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-24-linear_complexity)

Алгоритмы с линейной сложностью (O(n)) выполняются во времени, пропорциональном размеру входных данных. Это означает, что при увеличении размера входных данных вдвое, время выполнения алгоритма также увеличивается вдвое. Вот несколько примеров алгоритмов с линейной сложностью:

1. Линейный поиск: Линейный поиск - это алгоритм поиска элемента в неупорядоченном массиве или списке. Временная сложность линейного поиска - O(n), так как в худшем случае может потребоваться проверить каждый элемент.
```python
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

```

2. Итерация по всем элементам списка: Если вам нужно выполнить операцию на каждом элементе списка, например, вывод или преобразование каждого элемента, это также имеет временную сложность O(n), так как вы обрабатываете каждый элемент списка.
3. Суммирование элементов массива: Если вы хотите найти сумму всех элементов массива, вам придется пройти через каждый элемент, и временная сложность такой операции также будет O(n).
```python
def sum_of_elements(arr):
    total = 0
    for element in arr:
        total += element
    return total

```

4. Копирование элементов массива: Копирование элементов из одного массива в другой также имеет временную сложность O(n), так как вам нужно скопировать каждый элемент.
5. Подсчет количества вхождений элемента в массив: Если вы хотите узнать, сколько раз определенный элемент встречается в массиве, вам придется пройти через весь массив и подсчитать вхождения. Временная сложность такой операции - O(n).
```python
def count_occurrences(arr, target):
    count = 0
    for element in arr:
        if element == target:
            count += 1
    return count

```

Алгоритмы с линейной сложностью просты и понятны, но они могут быть менее эффективными на больших объемах данных по сравнению с алгоритмами, имеющими логарифмическую или константную сложность.
</details>
<details>
<summary>4.25 O(log n) - Логарифмическая сложность</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-25-logarithmic_complexity)

Алгоритмы с логарифмической сложностью (O(log n)) выполняются быстрее, чем линейные алгоритмы (O(n)), их скорость роста ограничивается логарифмически по отношению к размеру входных данных. 

Вот несколько примеров алгоритмов с логарифмической сложностью:

1. Бинарный поиск: Бинарный поиск - это алгоритм поиска элемента в упорядоченном массиве, который разделяет массив пополам на каждом шаге. Временная сложность бинарного поиска - O(log n), где n - количество элементов в массиве.
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

```

2. Двоичное дерево поиска: Двоичное дерево поиска - это структура данных, которая обеспечивает быстрый поиск, вставку и удаление элементов. Временная сложность операций в двоичном дереве поиска - в среднем O(log n), где n - количество узлов в дереве.
3. Быстрая сортировка (Quick Sort): В среднем случае быстрая сортировка имеет временную сложность O(n log n). Этот алгоритм разделяет массив на подмассивы, сортирует их и затем объединяет весь массив. В среднем время разделения и объединения составляет O(log n), а каждый подмассив сортируется за O(n).
4. Алгоритмы на основе деления и правления: Множество алгоритмов на основе деления и правления (divide and conquer), такие как быстрое возведение в степень, нахождение числа Фибоначчи и другие, имеют временную сложность O(log n) благодаря разделению задачи на более мелкие подзадачи и уменьшению размера данных на каждом шаге.
5. Алгоритмы на основе деревьев: Множество алгоритмов, работающих с деревьями, имеют логарифмическую сложность. Например, красно-черные деревья и AVL-деревья обеспечивают O(log n) для операций вставки, поиска и удаления элементов.

Алгоритмы с логарифмической сложностью являются эффективными и хорошо масштабируются для обработки больших объемов данных.
</details>
<details>
<summary>4.26 O(n^2) - Квадратичная сложность</summary>

[link]()

Алгоритмы с квадратичной сложностью (O(n^2)) выполняются во времени, пропорциональном квадрату размера входных данных. Это означает, что при увеличении размера входных данных вдвое, время выполнения алгоритма увеличивается в четыре раза. Вот несколько примеров алгоритмов с квадратичной сложностью:

1. Сортировка вставками (Insertion Sort): Сортировка вставками - это алгоритм сортировки, который поочередно вставляет каждый элемент массива в уже отсортированную часть массива. Временная сложность сортировки вставками - O(n^2) в худшем случае.
2. Сортировка выбором (Selection Sort): Сортировка выбором - это алгоритм сортировки, который на каждом шаге выбирает минимальный элемент из оставшихся и ставит его на правильное место. Временная сложность сортировки выбором - O(n^2) в худшем и среднем случаях.
3. Матричное умножение: При умножении двух матриц размером n x n с использованием стандартного метода, каждый элемент выходной матрицы вычисляется как сумма произведений элементов в соответствующей строке первой матрицы и столбце второй матрицы. Временная сложность матричного умножения - O(n^2).
4. Быстрая сортировка (Quick Sort) в худшем случае: В худшем случае быстрая сортировка может иметь квадратичную временную сложность, если опорный элемент каждый раз выбирается как самый большой или самый маленький элемент. Это случается, например, если массив уже отсортирован в обратном порядке.
5. Bubble Sort в худшем и среднем случае: Bubble Sort - это алгоритм сортировки, который проходит через массив многократно, сравнивая и обменивая соседние элементы. В худшем и среднем случае временная сложность Bubble Sort - O(n^2).

</details>
<details>
<summary>4.27 O(n log n) - Линейно-логарифмическая сложность</summary>

[link]()

Алгоритмы с линейно-логарифмической сложностью (O(n log n)) выполняются быстрее, чем линейные алгоритмы (O(n)), но медленнее, чем алгоритмы с логарифмической сложностью (O(log n)). Эти алгоритмы часто встречаются в сортировке и других задачах обработки данных. 

Вот несколько примеров алгоритмов с линейно-логарифмической сложностью:
1. Сортировка слиянием (Merge Sort): Сортировка слиянием - это алгоритм сортировки, который разделяет массив на две части, рекурсивно сортирует каждую часть, а затем объединяет их в отсортированный массив. Временная сложность сортировки слиянием - O(n log n) в худшем, среднем и лучшем случаях.
2. Быстрая сортировка (Quick Sort): Быстрая сортировка - это алгоритм сортировки, который разделяет массив на подмассивы, сортирует их и затем объединяет весь массив. Временная сложность быстрой сортировки - в среднем O(n log n), но в худшем случае может быть O(n^2).
3. Пирамидальная сортировка (Heap Sort): Пирамидальная сортировка - это алгоритм сортировки, который использует бинарное дерево (кучу) для эффективной сортировки. Временная сложность пирамидальной сортировки - O(n log n) в худшем и среднем случаях.

Алгоритмы с линейно-логарифмической сложностью обеспечивают эффективное сортировку и обработку данных на больших объемах.
</details>
<details>
<summary>4.29 Задача: Реализация собственного класса Dict</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-29-dict-practice)

Описание: Представьте, что в языке Python пропали встроенные словари (dict), и вам нужно создать собственный класс MyDict, который будет вести себя подобно словарю. Класс MyDict должен поддерживать следующие операции:
  1. `__init__()`: Инициализация пустого словаря.
  2. `__getitem__(key)`: Получение значения по ключу. Если ключ не существует, вернуть None.
  3. `__setitem__(key, value)`: Установка значения по ключу.
  4. `__delitem__(key)`: Удаление элемента по ключу. Если ключ не существует, ничего не делать.
  5. `keys()`: Возвращение списка всех ключей в словаре.
  6. `values()`: Возвращение списка всех значений в словаре.
  7. `items()`: Возвращение списка пар (ключ, значение) в словаре.
  8. `__str__()`: Возврат строкового представления словаря для удобства отладки.

Пример использования:
```python
my_dict = MyDict()
my_dict['name'] = 'Alice'
my_dict['age'] = 30
print(my_dict['name'])  # Вернет 'Alice'
print('city' in my_dict)  # Вернет False
del my_dict['age']
print(my_dict.keys())  # Вернет ['name']
print(my_dict.values())  # Вернет ['Alice']
```

Напишите класс MyDict, который реализует указанные операции. Ваш класс должен обеспечивать аналогичное поведение, как у встроенных словарей в Python.
</details>
<details>
<summary>5.1 Работа с файлами</summary>

[link](https://github.com/PavLikh/Technium/tree/master/05-technologies/5-1-files)

### Задание
Создайте текстовый файл с абзацем текста (абсолютно любого, может быть стихотворение, текст любимой песни или письмо от начальника). Код должен выдать статиску повторения слов в тексте - спискок различных слов и количество их повторения.

Пример работы программы:\
Введите название файла: hello.txt\
Кол-во слов: 66\
Кол-во уникальных слов: 54\
Все использованные слова:\
благодетель 2\
в 1\
всего 1\
вы 1\
горчичным 1\
ее 1\
ежели 3\
еще 1
</details>
<details>
<summary>5.2 CSV</summary>

[link](https://github.com/PavLikh/Technium/tree/master/05-technologies/5-2-csv)

### Задание 1
Имеется текстовый файл prices.txt с информацией о заказе из интернет магазина. В нем каждая строка с помощью символа табуляции \t разделена на три колонки: наименование товара; количество товара (целое число); цена (в рублях) товара за 1 шт. (целое число). Напишите программу, преобразующую данные из txt в csv.

### Задание 2
Имеется файл prices.csv (сформированный в прошлом задании) с информацией о заказе из интернет магазина. В нем каждая строка содержит три колонки: наименование товара; количество товара (целое число); цена (в рублях) товара за 1 шт. (целое число). Напишите программу, подсчитывающую общую стоимость заказа.
</details>