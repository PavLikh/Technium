# Technium

<details>
<summary>4.1 Декораторы</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-1-decorators)

## Задача 1.
Измерьте с помощью декоратора measure_execution_time продолжительность HTTP запроса к произвольному url (можно взять код из первых уроков по ботам)

## Задача 2. 
Описание задачи:

Необходимо разработать декоратор requires_admin, который будет использоваться для проверки роли пользователя перед выполнением защищенной функции. Если роль пользователя не соответствует требуемой, декоратор должен выбрасывать исключение PermissionError. В противном случае функция должна выполняться корректно.

### Пример использования:

Функция delete_user отвечает за удаление пользователей. Она должна быть доступна только для пользователей с ролью "admin".  Если пользователь, вызывающий эту функцию, не является администратором, необходимо остановить выполнение функции и выбросить PermissionError.

 
```python
@requires_admin
def delete_user(user, username_to_delete):
    return f"User {username_to_delete} has been deleted by {user['username']}."
```
### Пример юзеров
```python
admin_user = {'username': 'Alice', 'role': 'admin'}
regular_user = {'username': 'Bob', 'role': 'user'}
```

### Вызовы функции
```python
print(delete_user(admin_user, 'Charlie')) # Должно отработать
print(delete_user(regular_user, 'Charlie')) # Должно рейзить PermissionError
```

</details>
<details>
<summary>4.5 Задача (последовательность скобок)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-5-task)

## Описание задачи
Необходимо написать программу, которая проверяет, является ли данная строка правильной скобочной последовательностью. Правильной скобочной последовательностью считается последовательность, в которой каждая открывающая скобка (например, '(', '{', '[') имеет соответствующую закрывающую скобку (')', '}', ']'). При этом скобки должны быть правильно вложены друг в друга, и порядок их следования должен быть корректным.

Примеры:

Правильная скобочная последовательность: "([]{})"
Неправильная скобочная последовательность: "([)]"
Неправильная скобочная последовательность: "{[}"
Правильная скобочная последовательность: "()"

Задача включает в себя следующие шаги:

- Считать строку, содержащую скобочную последовательность.
- Используя стек, проверить каждую скобку в строке.
- Если текущая скобка - открывающая, добавить ее в стек.
- Если текущая скобка - закрывающая, проверить, соответствует ли она последней открывающей скобке в стеке. Если да, удалить последнюю открывающую скобку из стека и продолжить проверку. В противном случае, скобочная последовательность неправильна.
- По завершении проверки всех символов в строке, проверить, остались ли какие-либо непарные скобки в стеке. Если да, скобочная последовательность также считается неправильной.

Результатом выполнения программы должно быть сообщение о том, является ли данная строка правильной скобочной последовательностью или нет. В идеале код должен содержать реализацию класса Стек и функцию для проверки строки со скобками. 
</details>
<details>
<summary>4.6 Обратная польская нотация</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-6-reverse_polish_notation)

## Обратная польская запись (Reverse Polish Notation, RPN - она же постфиксная нотация, или обратная польская нотация (ОПН)) 
-это форма записи математических выражений, в которой операторы располагаются после своих операндов. Это также называется постфиксной записью. обратной польской записи порядок выполнения операций однозначно определяется, и не требуется использование скобок для указания приоритета операций.

Пример обратной польской записи:

Обычное инфиксное выражение: 3 + 4 * 2
Обратная польская запись: 3 4 2 * +

В обратной польской записи каждый операнд считывается, а затем оператор выполняется над двумя последними операндами. В данном случае, сначала выполняется умножение 4 * 2, а затем результат (8) складывается с 3, чтобы получить окончательный результат (11).

Обратная польская запись имеет несколько преимуществ:

1. Она исключает неоднозначность в приоритете операторов, так как порядок операций однозначно определяется последовательностью операторов.
2. Она облегчает вычисления на стеке, что делает ее полезной для реализации калькуляторов и интерпретаторов математических выражений.
3. Она упрощает анализ и вычисление выражений в программах.

Для вычисления выражения в обратной польской записи можно использовать стек. 

Алгоритм решения задачи обратной польской записи с использованием стека можно разбить на несколько шагов:

- Создать пустой стек для хранения операндов.
- Разбить строку входного выражения на токены (числа и операторы).
- Для каждого токена во входном выражении выполнить следующее:
    - Если токен - операнд (число), поместить его в стек.
    - Если токен - оператор (+, -, *, /), извлечь два верхних элемента из стека (это будут операнды), выполнить операцию с ними и результат поместить обратно в стек.
- После обработки всех токенов входного выражения, в стеке должен остаться единственный элемент - результат вычислений.
</details>
<details>
<summary>4.7 Очередь</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-7-queue)

</details>
<details>
<summary>4.8 Задача (очередь)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-8-task-queue)

Цель этого задания - создать программу для управления задачами с использованием структуры данных "очередь". Задачи будут представлены в виде объектов, и программа должна поддерживать операции добавления задачи в очередь, извлечения задачи из очереди и проверки состояния очереди.

### Требования 
1. Создайте класс TaskQueue, который будет представлять очередь задач. Этот класс должен иметь следующие методы:
    * add_task(task): Добавляет задачу task в конец очереди.
    * get_next_task(): Извлекает и возвращает задачу из начала очереди. Если очередь пуста, вернуть None.
    * is_empty(): Проверяет, пуста ли очередь. Возвращает True, если очередь пуста, и False в противном случае.
2. Создайте класс Task, который будет представлять задачу. Этот класс должен иметь атрибут:
    * name: Название задачи (строка).
3. Реализуйте логику работы с задачами в соответствии с их добавлением и извлечением из очереди.

Примеры тестовых данных и ожидаемых результатов:
```python
queue = TaskQueue()

task1 = Task("Задача 1")
task2 = Task("Задача 2")
task3 = Task("Задача 3")

queue.add_task(task1)
queue.add_task(task2)
queue.add_task(task3)

next_task = queue.get_next_task()
print(f"Следующая задача: {next_task.name if next_task else 'Нет задач'}")  # Ожидаемый результат: "Задача 1"

queue.get_next_task()  # Извлечь следующую задачу

print(f"Очередь пуста: {queue.is_empty()}")  # Ожидаемый результат: False
```

</details>
<details>
<summary>4.13 DFS через классы</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-13-graph_dfs_class)


### Задание 
Дописать реализацию функции dfs() для графа. Подсказка: в функции должны использоваться 2 структуры - Список для хранения пройденных вершин и Стек для хранения вершин-соседей, которые нужно пройти - алгоритм в предыдущем уроке сильно поможет. 


Для тестирования
```python
a = Node('a')
b = Node('b')
c = Node('c')
d = Node('d')
e = Node('e')
f = Node('f')
g = Node('g')
h = Node('h')
i = Node('i')
k = Node('k')
a.point_to(b)
b.point_to(c)
c.point_to(d)
d.point_to(a)
b.point_to(d)
a.point_to(e)
e.point_to(f)
e.point_to(g)
f.point_to(i)
f.point_to(h)
g.point_to(k)

g = Graph(a)
print(g.dfs())
```

</details>
<details>
<summary>4.15 Breadth-First через классы</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-15-graph-bfs-class)

```python
class Node:
    def __init__(self, value):
        self.value = value

        self.outbound = []
        self.inbound = []

    def point_to(self, other):
        self.outbound.append(other)
        other.inbound.append(self)

    def __str__(self):
        return f'Node({self.value})'

class Graph:
    def __init__(self, root):
        self._root = root

    def dfs(self):
        pass

    def bfs(self):
        pass
```

С нуля новый код писать не нужно. Если вы успешно справились с предыдущим заданием, то функция dfs() у вас уже реализована и код bfs() будет ооооочень сильно на нее походить, но с небольшим отличием в алгоритме.
</details>
<summary>4.17 Сортировка пузырьком (Bubble sort)</summary>

[link](https://github.com/PavLikh/Technium/tree/master/04-algorithms_data_structures/4-15-graph-bfs-class)

Сортировка пузырьком (Bubble Sort) - это простой алгоритм сортировки, который многократно проходит по списку, сравнивает пары соседних элементов и меняет их местами, если они находятся в неправильном порядке. Повторяйте этот процесс до тех пор, пока весь список не будет отсортирован. 

Вот пошаговое руководство по сортировке пузырьком:

Шаг 1:  Начните с начала списка.
Шаг 2:  Сравните первый и второй элементы списка. Если первый элемент больше второго, поменяйте их местами.
Шаг 3:  Перейдите к следующей паре элементов (второй и третий) и сравните их. Если второй элемент больше третьего, поменяйте их местами.
Шаг 4:  Продолжайте двигаться по списку, сравнивая и меняя элементы, пока не достигнете конца списка. На этом этапе наибольший элемент "всплывет" до конца списка.
Шаг 5:  Повторите шаги 1-4 для оставшейся части списка (исключая уже отсортированную часть).
Шаг 6:  Повторяйте эти шаги, пока весь список не будет отсортирован. Это может потребовать нескольких проходов.

Важно отметить, что на каждом проходе наибольший элемент "всплывает" до конца списка, поэтому после первого прохода самый большой элемент будет находиться в конце, после второго - в предпоследнем месте, и так далее. Этот процесс продолжается до тех пор, пока весь список не будет упорядочен.
</details>