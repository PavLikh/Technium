# Алгоритмы с линейной сложностью (O(n)) выполняются во времени, пропорциональном размеру входных данных. 
# Это означает, что при увеличении размера входных данных вдвое, время выполнения алгоритма также увеличивается вдвое.
# Вот несколько примеров алгоритмов с линейной сложностью:

# 1.Линейный поиск: Линейный поиск - это алгоритм поиска элемента в неупорядоченном массиве или списке. 
# Временная сложность линейного поиска - O(n), так как в худшем случае может потребоваться проверить каждый элемент.
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1
arr = [1, 2, 3, 4, 5]     
print('1.Линейный поиск', linear_search(arr, 3))


# 2.Итерация по всем элементам списка: Если вам нужно выполнить операцию на каждом элементе списка, например, вывод
# или преобразование каждого элемента, это также имеет временную сложность O(n), так как вы обрабатываете каждый элемент списка.
# 3.Суммирование элементов массива: Если вы хотите найти сумму всех элементов массива, вам придется пройти через каждый элемент,
# и временная сложность такой операции также будет O(n).
arr = [1, 2, 3, 4, 5]
def sum_of_elements(arr):
    total = 0
    for element in arr:
        total += element
    return total
print('2.Суммирование элеэлементов', sum_of_elements(arr))



# 3.ХКопирование элементов массива: Копирование элементов из одного массива в другой также имеет временную сложность O(n),
# так как вам нужно скопировать каждый элемент.
# 4.Подсчет количества вхождений элемента в массив: Если вы хотите узнать, сколько раз определенный элемент встречается в
# массиве, вам придется пройти через весь массив и подсчитать вхождения. Временная сложность такой операции - O(n).
arr = [1, 2, 3, 4, 5]
def count_occurrences(arr, target):
    count = 0
    for element in arr:
        if element == target:
            count += 1
    return count
print('4.Подсчет количества:', count_occurrences(arr, 2))

# Алгоритмы с линейной сложностью просты и понятны, но они могут быть менее эффективными на больших объемах данных по сравнению 
# с алгоритмами, имеющими логарифмическую или константную сложность.
